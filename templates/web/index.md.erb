% render "layouts/basic.html" do

%# HTML tags can be embedded in mark down files if you want to do specific custom
%# formatting like this, but in most cases that is not required.
<h1><%= Origen.app.namespace %> <span style="font-size: 14px">(<%= Origen.app.version %>)</span></h1>

# Purpose

This is a plug-in for Origen that enables live silicon debug directly from origen source.  There are 2 parts to OrigenLink, the plug-in and the server.  Setup for each is documented separately.

# Plug-in

Instructions for integrating and using the plug-in with your app.

## How To Import

* Add the following line to your application's GEMFILE:

~~~ruby
 gem 'origen_link'
~~~


* Add a link environment (./environment/link.rb).  See server setup section for more information:

~~~ruby
OrigenLink::VectorBased.new('<ServerComputerName>', 12777)
~~~


* Select link as your environment to run a pattern over the link connection when the origen generate command is run:

~~~
origen e environment/link.rb
origen g pattern/my_pattern.rb
~~~ 


## How To Configure

Before OrigenLink can be used the physical pin map and timing must be setup.  There are 2 supported ways of doing this.  The high-level setup method allows OrigenLink to determine how to configure the server side pin sequencer.  The high-level setup method is highly recommended.  For cases where the high-level setup is not functioning correctly, legacy apps, or if you just enjoy doing things the hard way, a legacy low-level api is available.  Both will be described here.

### How To Configure - High-Level Method (Preferred)

This is the recomended way to setup OrigenLink in your application.

#### Physical Pin Map

OrigenLink needs to tell the server application which physical IO pin on the UDOO device (see UDOO-Neo GPIO documentation) corresponds to which DUT pin in your app.  The number after 'gpio_' is what OrigenLink needs.  This IO number is passed to OrigenLink through pin meta data.

~~~ruby
add_pin :tclk, meta: {link_io: 8}
add_pin :tdi, meta: {link_io: 146}
~~~

#### Timing

OrigenLink emulates a tester sequencer through software.  The timing it implemtents will not be precise.  Setting the drive edge of tdi to 5ns and tclk to 20ns will not result in tclk being driven 15ns after tdi.  What will happen, though, is the sequencer will drive tdi first, followed by tclk.  It is recommended that you use the built in Origen API for setting timing.

~~~ruby
  # Configure timing for jtag communication with RL tclk
  tester.set_timeset('api_tst', 40)
  dut.timeset :api_tst do |t|
    t.drive_wave :tclk do |w|
      w.drive :data, at: 10
      w.drive 0, at: 30
    end
    t.drive_wave :tdi, :tms, :tdo do |w|
      w.drive :data, at: 5
    end
    t.compare_wave do |w|
      w.compare :data, at: 25
    end
  end
~~~

#### Finished

Start your OrigenLink server (see server setup section), connect your DUT to the server device and off you go.

### How To Configure - Low-Level Legacy API (Skip Reading This Section)

The prefered configuration method is above.  These methods for configuring the server application are supported for legacy applications.  This method is more prone to producing hard to debug errors during setup of a new app.

#### Low-Level Physical Pin Map Setup

Create a comma separated list of pin_name and IO# and pass it to the tester.  The .pinmap method will clear all server settings.  So, this should be done first.  The pin name string provided to the pinmap must exactly match the pin name string provided to the pin timing and pin order methods.  Any typo may result strange behavior (pin operation not occuring, timing error messages, and/or server crash).  No cause for alarm, just be sure to check for consistent names if you get those problems.

~~~ruby
  tester.pinmap = 'tclk,119,tms,6,tdi,116,tdo,124'
~~~

#### Low-Level Pattern Pin Order Setup

Pins that don't have an assiciated physical IO will not have their pin data transmitted to the link server.  Create a comma separated list of the pins that are linked (only include pins that are in the pinmap) in the order that they appear in the pattern.  Using this command is not needed unless you used the low-level pin map setup command AND your dut.pins(:pin_name) doesn't match the pin name that you setup using 'tester.pinmap ='.

~~~ruby
  pin_pattern_order :tclk, :tms, :tdi, :tdo	# This sets the order of the pins in the pattern

  # order given below must match order in pin_pattern_order
  # names used below must match names used in tester.pinmap=
  # the below example will cause issues because of a typo: 'tck' versus 'tclk' (tester.pinmap = 'tclk,119,)
  tester.pinorder = 'tck,tms,tdi,tdo'		# This tells the server what order the pins are in the pattern
~~~

#### Low-Level Timing Setup

Info on low level timing api will be here shortly

### Debugging Your App

What follows are some pointers for using OrigenLink to debug your app (or pattern).  Run the origen pattern generation command with debug enabled and set a break point in your code to interactively debug.

~~~
origen g pattern/my_pattern.rb -d
~~~

~~~ruby
  # inside pattern/my_pattern.rb

  dut.reg(:MyReg).write!(my_value)

  # stop after updating this register to observe device state
  debugger	# generation of the pattern will pause here
~~~

#### Staying Synchronized

For efficiency vectors that are generated by your app are compressed and stored until the pattern generation is completed.  This means that when execution reaches a 'debugger' statement the previously generated patterns may not have been sent to the server yet.  There are a handful of ways to make this happen.

* Use the tester.synchronize command from the debugger interface:

~~~
  # one time synchronize
  (debugger prompt): tester.synchronize

  # tell debugger to evaluate the synchronize command every time it gets control
  # will cause continuous synchronization
  (debugger prompt): disp tester.synchronize
~~~

* Use tester.transaction (makes the most sense to have this in your app's reg read/write methods).  Before the transaction method executes the code block provided it will perform a synchronization.  Then, the code in the block is executed (which generates new vectors) and a second synchronization is performed.  The transaction method returns a boolean indicating whether the vectors generated by the code block passed or failed.

~~~ruby
  result = tester.transaction { dut.jtag.shift_xx (yy) }
  if tester.link?
    # result = true if the code in the provided block passed
  end
~~~

#### Capturing DUT Information

There are a few methods for observing the actual state of the DUT.

* Capture using tester.capture

~~~ruby
  # example of capturing and programatically using information read from the DUT
~~~

* Capture using mem api

~~~ruby
  # example of mem api use
~~~

* reg.sync!

~~~
  (debugger prompt): dut.reg(:MyReg).sync! 
~~~

# Server

## Setting Up a New UDOO device

## Starting the Server

## Physical Interconnect

% end
